# Введение в язык программирования Си. Из книги Эндрю Таненбаума «Operating Systems Design and Implementation»

Адаптированный вариант статьи [Введение в Си. Послание из прошлого столетия / Хабр](https://habr.com/ru/post/464075/)

![](https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png)

Язык программирования Cи был создан Деннисом Ритчи из AT&T Bell Laboratories как язык программирования высокого уровня для разработки операционной системы UNIX. В настоящее время язык широко используется в различных областях. C особенно популярен у системных программистов, потому что позволяет писать программы просто и кратко.  

Основной книгой, описывающая язык Cи, является книга Брайана Кернигана и Денниса Ритчи « Язык программирования Cи» (1978). Книги по языку Си писали Bolon (1986), Gehani (1984), Hancock and Krieger (1986), Harbison и Steele (1984) и многие другие. 

### А.1. Основы языка Си

Программа на Cи состоит из набора функций, даже если они не возвращают значений). Эти функции содержат объявления, операторы и другие элементы, которые вместе говорят компьютеру что надо делать. На рисунке A-1 показана небольшая функция, в которой объявляются три целочисленные переменные и присваиваются им значения. Имя функции main (главная). Функция не имеет формальных параметров, на что указывает отсутствие каких-либо идентификаторов между скобками за именем функции. Тело функции заключено в фигурные скобки ( { } ). Этот пример показывает, что Cи имеет переменные, и что эти переменные должны быть объявлены до использования. Cи также имеет операторы, в этом примере это операторы присваивания. Все операторы должны заканчиваться точкой с запятой. 

Комментарии начинаются с символов  `/ *` и заканчивается символами `*/` и могут занимать несколько строк.  

```c
main()          /* это комментарий */
{
     int i, j, k;         /* объявление 3 целочисленных переменных */
     i = 10;              /* присвоить i значение 10 (десятичное число) */
     j = i + 015;         /* присвоить j значение  i + 015 (восьмеричное число) */
     k = j * j + 0xFF;    /* установить k в j * j + 0xFF (шестнадцатеричное число) */
}

Рис. A-l. Пример функции в Си.
```

Функция содержит три константы. Константа 10 в первом присваивании  это обычная десятичная константа. Константа 015 является восьмеричной константой  (равно 13 в десятичной системе счисления). Восьмеричные константы всегда начинаются с начального нуля. Константа 0xFF является шестнадцатеричной константой (равной 255 десятичной). Шестнадцатеричный константы всегда начинаются с 0x. Все три типа используются в Cи. 

### А.2. Основные типы данных

Cи имеет два основных типа данных (переменных): целое и символ, объявляемые как int и char, соответственно. Нет отдельной булевой переменной. В качестве булевой переменной используется переменная int. Если эта переменная содержит 0, то это означает ложь/false, а любое другое значение означает истина/true. 

К типу `int` можно применять «прилагательные» `short`, `long` или `unsigned`, которые определяют (зависящий от компилятора) диапазон значений. 

Некоторые объявления показаны на рис. А — 2.  

```c
int i;                  /* одно целое число */
short int z1, z2;       /* два коротких целых числа */
char c;                 /* один символ */
unsigned short int k;   /* одно короткое целое без знака */
long flag_poll;         /* 'int' может быть опущено */

Рис. А-2. Некоторые объявления.
```

Преобразование между типами разрешено. Например, оператор  

```c
flag_pole = i;
```

разрешен, даже если i имеет тип int, а flag_pole — long. Во многих случаях  необходимо или полезно принудительно проводить преобразования между типами данных. Для принудительного преобразования достаточно поставить целевой тип в скобках перед выражением для преобразования. Например:  

```c
func ( (long)i );
```

предписывает преобразовать целое число i в long перед передачей его в качестве параметра в функцию func, которая ожидает именно параметр long.

### А.3. Составные типы и указатели

В этом разделе мы рассмотрим четыре способа построения более сложных типов данных: массивы, структуры, объединения и указатели (arrays, structures, unions, and pointers). Массив — это коллекция/множество элементов одного типа. Нумерация всех массивов в Cи начинаются с 0.  

Объявление  

```c
int a[10];
```

объявляет массив a с 10 целыми числами, которые будут хранится в элементах массива от [0] до a [9]. Массивы могут быть двух и более измерений.  
Структура — это набор переменных, обычно разных типов.  Оператор  

```c
struct {
    int i; 
    char c;
} st;
```

объявляет st как структуру, содержащую два члена, целое число i и символ c.  

Чтобы присвоить члену `i` структуры `st` значение 6, нужно записать следующее выражение:  

```c
st.i = 6;
```

где оператор точка указывает, что элемент i принадлежит структуре s.  
Объединение — это также набор членов, аналогично структуре, за исключением того, что в любой момент в объединение может находится только один из них. Объявление  

```c
union {
    int i; 
    char c;
} u;
```

означает, что вы можете иметь целое число или символ, но никак не оба. Компилятор должен выделить достаточно места для объединения, чтобы в нем мог разместиться самый большой (с точки зрения занимаемой памяти) элемент объединения. Объединения используются достаточно редко. 

Указатели используются для хранения машинных адресов в Cи. Они используются очень и очень часто. Символ звездочка (*) используется для обозначения указателя в объявлениях. Объявление  

```c
int i, *pi, a[10], *b[10], **ppi;
```

объявляет целое число `i`, указатель на целое число `pi`, массив `a` из 10 элементов, массив `b` из 10 указателей на целые числа и указатель на указатель `ppi` на целое число.  

Точные правила синтаксиса для сложных объявлений, объединяющих массивы, указатели и другие типы несколько сложны.  

На рисунке A-3 показано объявление массива z структур `struct table`, каждая из которых имеет  три члена, целое число i, указатель cp на символ и символ с.  

```c
struct table {     /* каждая структура имеет тип таблицы */
    int i;         /* целое число */
    char *cp, c;   /* указатель на символ и символ */
} z[20];           /* это массив из 20 структур */
```

Далее, имя table можно объявить как структуру struct table, которую можно использовать в последующих объявлениях. Например,  

```c
struct table *p;
```

объявляет p указателем на структуру `struct table`. Во время выполнения программы p может указывать, например, на `z[4]` или  на любой другой элемент в z, все 20 элементов которой являются структурами типа struct table.  

Чтобы сделать p указателем на `z[4]`, достаточно написать  

```c
p = &z[4];
```

где амперсанд в качестве унарного (монадического) оператора означает «взять адрес того, что за ним следует». Скопировать в целочисленную переменную `n` значение члена `i` структуры, на которую указывает указатель р, можно следующим образом:  

```c
n = p->i;
```

Обратите внимание, что стрелка используется для доступа к члену структуры через указатель. Если мы будем использовать переменную z, то тогда мы должны использовать оператор с точкой:  

```c
n = z[4].i;
```

Разница в том, что `z[4]` является структурой, и оператор точки выбирает элементы  из составных типов (структуры, массивы) напрямую. С помощью указателей мы не выбираем участника напрямую. Указатель предписывает сначала выбрать структуру и только потом выбрать члена этой структуры.  

Иногда удобно дать имя составному типу. Например:  

```c
typedef unsigned short u_short;
```

определяет `u_short` как `unsigned short` (короткое целое число без знака). Теперь `u_short` может быть использован в программе как основной тип. Например,  

```c
u_short ul, *u2, u3[5];
```

объявляет короткое целое число без знака, указатель на короткое целое число без знака и  массив коротких целых без знака.  

### А.4. Операторы

Функции в Cи содержат объявления и операторы. Мы уже видели объявления, так что теперь мы будем рассматривать операторы. Назначение условного оператора и операторов цикла по существу такие же, как и в других языках. Рисунок А – 4 показывает несколько примеров из них. Единственное, на что стоит обратить внимание, это то, что фигурные скобки используются для группировки операторов, а оператор while имеет две формы. 

Cи также имеет оператор `for`. Оператор `for` имеет следующий вид:  

```c
for (<инициализация>; <условие>; <выражение>) оператор;
```

Тоже самое можно выразить через опертор `while`:  

```c
<инициализация>
while(<условие>) {
    <оператор>;
    <выражение>
} 
```

В качестве примера рассмотрим следующий оператор:  

```c
for (i=0; i <n; i = i+l) 
    a[i]=0;
```

Этот оператор устанавливает первые n элементов массива a равными нулю. Выполнение оператора начинается с установки i в ноль (это делается вне цикла). Затем оператор повторяется до тех пор, пока i < n, выполняя при этом присваивание и увеличение i. Конечно, вместо оператора присвоения значения текущему элементу массива нуля может быть составной оператор (блок), заключенный в фигурные скобки.  
**На бассейне использование `for`  запрещено.**

```c
if (x < 0) k = 3;        /* простое оператор if */

if (x > y) {             /* составной оператор if */
     i = 2;
     k = j + l,
}

if (x + 2 <y) {          /* оператор if-else */
      j  = 2;
      k = j - 1;
} else {
      m = 0;
}

while (n > 0) {          /* оператор while */
     k = k + k;
     n = n - l;
}

do {                     /* другой вид оператора while */
      k = k + k;         /* Запрещен для Бассейна */
      n = n - 1;
} while (n >  0);

Рис. A-4. Примеры операторов if и while в Cи.
```

**На бассейне использование `do while` запрещено.**

Си имеет также  switch-оператор. Пример представлен на рисунке А-5. В зависимости от значения выражения, указанного в `switch`, выбирается тот или иной оператор cаse.  

Если выражение не соответствует ни одному из операторов case, то выбирается оператор по умолчанию (`default`).  

Если выражение не связано ни с одним оператором case и оператор default отсутствует, то выполнение продолжается со следующего оператора после оператора `switch`.  

Следует отметить, что для выхода из блока case следует использовать оператор `break`. Если оператор `break` отсутствует, то будет выполняться следующий блок case.  

```c
switch (k) {
      case 10:
            i = 6;
            break;      /* не выполнять case 20, т.е. завершить выполнение опертора switch */
      case 20:
             i = 2;
             k = 4;
             break;     /* не выполнять default */
      default:
            j = 5;
}

Рис. A-5. Пример оператора switch
```

**На бассейне оператор `switch` запрещён.**

Оператор `break` также действует внутри циклов `for` и `while`. При этом надо помнить, что если оператор break находится внутри серии вложенных циклов, выход осуществляется только на один уровень вверх.  

Связанным оператором является оператор `continue`, который не выходит из цикла,  но вызывает завершение текущей итерации и начало следующей итерации  немедленно. По сути, это возврат к вершине цикла.  

Cи имеет функции, которые могут вызываться с параметрами или без параметров.  Согласно Кернигану и Ричи, не разрешено передавать массивы,  структуры или функции в качестве параметров, хотя передача указателей на все это  допускается. В настоящее время это не так,  все компиляторы языка Си допускают структуры в качестве параметров. 
Имя массива, если оно написано без индекса, означает указатель на массив, что упрощает передачу указателя массива. Таким образом, если a является именем массива любого типа, его можно передать в функцию `g`, написав  

```c
g(а);
```

Это правило действует только для массивов, на структуры это правило не расапространяется.
функции могут возвращать значения, выполняя оператор return. Этот оператор может содержать выражение, результат выполнения которого будет возвращено в качестве значения функции, но вызвавшая функция может смело игнорировать возвращаемое значение. Если функция возвращает значение, то тип значение записывается перед именем функции, как показано на рис. A-6. Аналогично параметрам, функции не могут возвращать массивы, структуры или функции, но могут вернуть указатели на них. Это правило разработано для более эффективной реализации — все параметры и результаты всегда соответствуют одному машинному слову (в котором хранится адрес). Компиляторы, которые допускают использование структур в качестве параметров, обычно также допускают их использование в качестве возвращаемых значений.

```c
int sum(int i, int j)    /* эта функция возвращает целое число */
{
    return (i + j);       /* добавить параметры и вернуть сумму */
}

Рис. А-6. Пример простой функции, которая возвращает значение.
```

C не имеет встроенных операторов ввода / вывода. Ввод/вывод реализуется путем вызова библиотечных функций, наиболее распространенные из которых проиллюстрированы ниже:  

```c
printf ("x = %d y = %o z = %x\n", x, y, z);
```

Первый параметр — это строка символов между кавычками (на самом деле это массив символов).  

Любой символ, который не является процентом, просто печатается как есть.  
Когда встречается процент, печатается следующий параметр в виде, определяемом буквой, следующей за процентом:  

> d — вывести в виде десятичного целого числа  
> o — печатать как восьмеричное целое  
> u — печатать как беззнаковое десятичное целое  
> x — печатать как шестнадцатеричное целое  
> s — печатать как строку символов  
> c — печатать как один символ

Также допускаются буквы D, 0 и X для десятичной, восьмеричной и шестнадцатеричной печати длинных чисел.  

### А.5. Выражения

Выражения создаются путем объединения операндов и операторов.  

Арифметические операторы, такие как `+` и `-`, и операторы сравнения, такие как <  и > похожи на своих аналогов в других языках. Оператор %  нахождения остатка ()деления по модулю.) Стоит отметить, что оператор равенства это `==`, а оператор неравенства это `!=`. Чтобы проверить равны ли a и b, можно написать так:  

```c
if (a == b) <оператор>;
```

Си также позволяет объединять оператор присваивания с другими операторами, поэтому  

```c
a += 4;
```

эквивалентно записи  

```
а = а + 4;
```

Другие операторы также могут быть объединены таким образом.  

Си имеет операторы для манипулирования битами слова. Разрешены как сдвиги, так и побитовые логические операции. Операторы сдвига влево и вправо являются <<  
и >> соответственно. Побитовые логические операторы `&`, `|` и `^` , которые являются логическим И (AND), включающим ИЛИ (OR) и исключающим ИЛИ (XOP) соответственно. Если i имеет значение 035 (восьмеричное), тогда выражение i & 06 имеет значение 04 (восьмеричное). Еще один пример, если i = 7, то  

```c
j = (i << 3) | 014;
```

и получим 074 для j.  
Другой важной группой операторов являются унарные операторы, каждый из которых принимает только один операнд. Как унарный оператор, амперсанд `&` получает адрес переменной.  

Если p является указателем на целое число, а i является целым числом, оператор  

```c
p = &i;
```

вычисляет адрес i и сохраняет его в переменной p.  
Противоположным взятию адреса является оператор, который принимает указатель в качестве входных данных и вычисляет значение, находящееся по этому адресу. Если мы только что присвоили адрес i указателю p, тогда *p имеет то же значение, что и i.  

Другими словами, в качестве унарного оператора за звездочкой следует указатель (или  выражение, дающее указатель), и возвращает значение элемента, на который указывает. Если i имеет значение 6, то оператор  

```c
j = *р;
```

присвоит j число 6.  
Оператор `!` (восклицательный знак – оператор отрицания) возвращает 0, если его операнд отличен от нуля, и 1, если его оператор равен 0.  
Он в основном используется в операторах if, например  

```c
if (!x) k=0;
```

проверяет значение х. Если x равен нулю (false), то k присваивается значение 0. В действительности, оператор! отменяет условие, следующее за ним.

Оператор `~` является побитовым оператором дополнения. Каждый 0 в своем операнде  становится 1, а каждый 1 становится 0.  

Оператор sizeof сообщает размер его операнда в байтах. Применительно к  
массиву из 20 целых чисел a на компьютере с 4-байтовыми целыми числами, например sizeof a будет иметь значение 80.  

Последняя группа операторов — это операторы увеличения и уменьшения.  

Оператор  

```c
р++;
```

означает увеличение р. На сколько увеличится p, зависит от его типа.  Целые числа или символы увеличиваются на 1, но указатели увеличиваются на  размер объекта, на который указывает Таким образом, если а является массивом структур, а р указатель на одну из этих структур, и мы пишем  

```c
p = &a[3];
```

чтобы заставить p указать на одну из структур в массиве, то после увеличения p  будет указывать на a[4] независимо от того, насколько велики структуры. Оператор  

```c
p--;
```

аналогичен оператору p++, за исключением того, что он уменьшает, а не увеличивает значение операнда.  

В операторе  

```c
n = k++;
```

где обе переменные являются целыми числами, исходное значение k присваивается n и  
только после этого происходит увеличение k. В операторе  

```
n = ++k;
```

сначала увеличивается k, затем его новое значение сохраняется в n.  

Таким образом, `++` (или `--`) оператор может быть записан до или после его операнда, что приводит к получению различных значений.  

Последний оператор – это `?` (знак вопроса), который выбирает одну из двух альтернатив  разделеных двоеточием. Например, оператор,  

```c
i = (x < y ? 6 : k+1);
```

сравнивает `х` с `у`. Если x меньше `y`, тогда` i `получает значение `6`; в противном случае переменная` i `получает значение `k + 1`. Скобки не обязательны.  

### А.6. Структура программы

Программа на С состоит из одного или нескольких файлов, содержащих функции и объявления.  
Эти файлы могут быть скомпилированы по отдельности в объектные файлы, которые затем линкуются друг с другом (с помощью компоновщика) для формирования исполняемой программы.  
Объявления функций не могут быть вложенными, поэтому все они записываются на «верхнем уровне» в файле программы.  

Допускается объявлять переменные вне функций, например, в начале файла перед первым объявлением функции. Эти переменные являются глобальными, и могут использоваться в любой функцийе во всей программе, если только ключевое слово static не предшествует объявлению. В этом случае эти переменные нельзя использовать в другом файле. Те же правила применяются к функциям. Переменные, объявленные внутри функции являются локальными для функции. Финкция может обращаться к целочисленной переменной v, объявленной в другом файле (при условии, что переменная не является статической), объявляя ее у себя внешней:  

```c
extern int v;
```

Каждая глобальная переменная должна быть объявленным ровно один раз без атрибута extern, чтобы выделить память под нее.  

Переменные могут быть инициализированы при объявлении:  

```c
int size = 100;
```

Массивы и структуры также могут быть инициализированы. Глобальные переменные, которые не инициализированы явно, получают значение по умолчанию, равное нулю.  

### А.7. Препроцессор Cи

Прежде чем исходный файл будет передан компилятору Cи, он автоматически обрабатывается  программой под названием препроцессор. Именно выход препроцессора, а не  оригинальная программа, подается на вход компилятора. Препроцессор выполняет  три основных преобразования в файле перед передачей его компилятору:  

1. Включение файлов.  
2. Определение и замена макросов.  
3. Условная компиляция.  

Все директивы препроцессора начинаются со знака числа (#) в 1-ом столбце.  
Когда директива вида  

```c
#include "prog.h"
```

встречается препроцессором, он включает файл prog.h, строка за строкой, в  программу, которая будет передана компилятору. Когда директива `#include `написана как  

```c
#include <prog.h>
```

то включаемый файл ищется в каталоге /usr/include вместо рабочего каталога. В Cи распространена практика группировать объявления, используемые несколькими файлами, в заголовочном файле (обычно с суффиксом .h), и включать их там, где они необходимы.  
Препроцессор также позволяет определения макросов. Например,  

```c
#define BLOCK_SIZE 1024
```

определяет макрос BLOCK_SIZE и присваивает ему значение 1024. С этого момента  каждое вхождение строки из 10 символов «BLOCK_SIZE» в файле будет  заменяться 4-символьной строкой «1024» до того, как компилятор увидит файл с программой. По соглашению имена макросов пишутся в верхнем регистре. Макросы могут иметь параметры, но на практике немногие это делают.  

Третья особенность препроцессора — условная компиляция. В MINIX есть несколько мест, где код написан специально для процессора 8088, и этот код не должен включаться при компиляции для другого процессора. Эти разделы выглядят как так:  

```c
#ifdef i8088
      <объявления только для 8088>
#endif
```

Если символ i8088 определен, то операторы между двумя директивами препроцессора #ifdef i8088 и #endif включаются в выходные данные препроцессора; в противном случае они пропускаются. Вызывая компилятор с командой  

```bash
cc -c -Di8088 prog.c
```

или включив в программу заявление  

```c
#define i8088
```

мы определяем символ i8088, поэтому весь зависимый код для 8088 быть включен. По мере развития MINIX он может приобрести специальный код для 68000s и других процессоров, которые будут обрабатываться также.  

В качестве примера того, как работает препроцессор, рассмотрим программу рис. A-7 (a). Она включает в себя один файл prog.h, содержимое которого выглядит следующим образом:  

```c
int x;
#define MAXAELEMENTS 100
```

Представьте, что компилятор был вызван командой  

```bash
cc -E -Di8088 prog.c
```

После того, как файл прошел через препроцессор, вывод будет таким, как показано на Рис. A-7 (b).  

Именно этот вывод, а не исходный файл, дается как вход в Cи компилятор.  

```
#include prog.h 			        		int x;
main ()										main ();
{											{
      int a[MAX_ELEMENTS]; 					int a [100];
      х = 4;					   				х = 4;
      a[x] = 6; 				   				а[х] = 6;
#ifdef i8088 					   				printf("8088. a[x]:% d\n", a[x]);
      printf ("8088. a[x]:% d\n", a[x]);
#endif										}

#ifdef m68000
      printf ("68000. x=%d\n", x);
#endif
}
            (а) 				     		(b)

Рис. А-7. (a) Содержание файла prog.c. (b) Выход препроцессора.
```

Обратите внимание, что препроцессор выполнил свою работу и удалил все строки, начинающиеся со знаком #. Если компилятор был бы вызван так  

```bash
cc -c -Dm68000 prog.c
```

то была бы включена другая печать. Если бы он был вызван вот так:  

```bash
cc -c prog.c
```

то ни одна печать не была бы включена. (Читатель может поразмышлять о том, что случилось бы, если бы компилятор вызывался с обоими флагами -Dﬂags.)  

### А.8. Идиомы

В этом разделе мы рассмотрим несколько конструкций, которые характерны для Cи, но не распространены в других языках программирования. Для начала рассмотрим цикл:  

```
while (n--) *p++ = *q++;
```

Переменные p и q обычно являются символьными указателями, а n является счетчиком. Цикл копирует n-символьную строку из места, на которое указывает q, в место, на которое указывает р. На каждой итерации цикла счетчик уменьшается, пока он не доходит до 0, и каждый из указателей увеличивается, поэтому они последовательно указывают на ячейки памяти с более высоким номером.  

Еще одна распространенная конструкция:  

```c
for (i = 0; i < N; i++) a[i] = 0;
```

которая устанавливает первые N элементов а в 0. Альтернативный способ написания этого цикла выглядит так:  

```
for (p = &a[0]; p < &a[N]; p++) *p = 0;
```

В этой формулировке целочисленный указатель p инициализируется так, чтобы указывать на нулевой элемент массива. Цикл продолжается до тех пор, пока p не достиг адреса N-ого элемента массива. Конструкция указателя гораздо эффективнее, чем конструкция массива, и поэтому обычно используют ее.  

Операторы присвоения могут появляться в неожиданных местах. Например,  

```c
if (a = f (x))  < оператор >;
```

сначала вызывает функцию f, затем присваивает результат вызова функции a и  наконец, проверяет, является ли оно истинным (ненулевым) или ложным (нулевым). Если а не равно нулю, то условие выполнено. Оператор  

```c
if (a = b) < оператор >;
```

также сначало значение переменной b переменной a, а затем проверяет a, не является ли значение ненулевым. И этот оператор полностью отличается от  

```c
if (a == b)  < оператор >;
```

который сравнивает две переменные и выполняет оператор, если они равны.  

Добавлю, что использовать оператор присваивания таким способом категорически не рекомендуется, это легкий способ допустить ошибку и сделать код абсолютно нечитаемым. Современный компилятор С выдаст предупреждение в таких случаях.

### Послесловие

Вот и все. Вы не поверите, какое я получил огромное удовольствие, готовя этот текст. Как много я вспомнил полезного из того же языка Си. Надеюсь, вы тоже с удовольствием окунетесь в прекрасный мир языка Си.
