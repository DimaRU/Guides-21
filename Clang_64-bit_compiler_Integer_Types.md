# Clang 64-bit compiler

### Integer types storage sizes and value ranges

| signed         | bytes | min         | max        | Dectmal digits |
|----------------|------:|------------:|-----------:|---------------:|
| char           | 1     | -128        | 127        | 3
| short          | 2     | -32768      | 32767      | 5
| int            | 4     | -2147483648 | 2147483647 | 10
| long           | 8     | -2^63       | 2^63-1     | 19
|----------------|-------|-------------|------------| --------------------
| unsigned char  | 1     | 0           | 255        | 3
| unsigned short | 2     | 0           | 65535      | 5
| unsigned int   | 4     | 0           | 4294967295 | 10
| unsigned long  | 8     | 0           | 2^64-1     | 20


### Немного о двоичной арифметике.

В отличие от математического представления переменной, где целое число может быть сколь угодно большим, компьютерное представление переменной весьма ограничено. Выше в таблице эти ограничения указаны. Что произойдёт, если выйти за границу допустимого значения переменной, к примеру к переменной типа signed short со значением `32767` прибавить `1`? Результат будет неожиданным: `-32768`. И наоборот, если из `-32768` вычесть `1`, результат будет равен `32767`. Эта ситуация называется переполнением (overflow), и её нужно учитывать при написании кода. Для unsigned short в результате переполнения будет переход через 0: `65535 + 1` будет равно `0`.
Да, и ещё нужно помнить: для всех целочисленных со знаком максимальное отрицательное значение не имеет положительного аналога. Например:

```C
int variable;
int negated_variable;
variable = -2147483648;
negated_variable = -variable;
```

Чему будет равно значение `negated_variable`? Упс, значение не изменилось: `-2147483648`. Это тоже случай переполнения. Язык С никак не обнаруживает переполнение, нужно это учитывать. (В других языках это может быть не так).

Для бассейна скорее всего этого материала хватит.